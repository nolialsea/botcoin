const cfg = require('configuration');
const User = require('user');
const Pickaxe = require('pickaxe');
const client = require('ircclient');

function output(to, message){
	client.say(to, message);
}

//Connection (example command)
let connect = function(nick, msg){
	//First regex should math only the first word
	let reg = new RegExp("^connect","i")
	let res = msg.match(reg);
	if (res){
		//Second regex can then extract arguments and process them however
		reg = new RegExp("^connect ([^ ]*) ([^ ]*$)","i")
		res = msg.match(reg);
		if (res){
			if (res.length === 3){
				let login = res[1];
				let password = res[2];
				User.connect(nick, login, password, function(connected){
					if (connected === 2){
						output(nick, "Yep. Connected.");
					}else if(connected === 1){
						output(nick, "That account is already connected.");
					}else if(connected === 0){
						output(nick, "Nope. Bad password.");
					}else if (connected === -1){
						output(nick, "Nope. No account with this login");
					}else{
						output(nick, "Wtf ?! You shouldn't see this, that's clearly a bug.");
					}
				});
			}else{
				output(nick, "Nope. You don't use it correctly. Maybe try the \"connect help\" command ?");
			}
		}

		//You can also match different arguments
		reg = new RegExp("^connected","i");
		res = msg.match(reg);
		if (res){
			User.getByNick(nick, function(user){
				if (!user){
					output(nick, "Nope, you are not connected.");
				}else{
					output(nick, "Yep, you are connected.");
				}
			});
		}

		//Help
		reg = new RegExp("^connect help","i")
		res = msg.match(reg);
		if (res){
			output(nick, "https://github.com/nolialsea/botcoin");
		}
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

//Registration
let register = function(nick, msg){
	let reg = new RegExp("^register","i")
	let res = msg.match(reg);
	if (res){
		reg = new RegExp("^register ([^ ]*) ([^ ]*$)","i");
		res = msg.match(reg);
		if (res){
			if (res.length === 3){
				let login = res[1];
				let password = res[2];
				User.register(nick, login, password, function(registered){
					if (registered){
						output(nick, "Yep. Registered and connected.");
					}else{
						output(nick, "Nope. Somebody already have this login or something.");
					}
				});
			}else{
				output(nick, "Nope. You don't use it correctly. Maybe try the \"register help\" command ?");
			}
		}
		
		reg = new RegExp("^register help","i")
		res = msg.match(reg);
		if (res){
			output(nick, "https://github.com/nolialsea/botcoin");
		}
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

//Mining
let mine = function(nick, msg){
	let reg = new RegExp("^mine","i")
	let res = msg.match(reg);
	if (res){
		User.getByNick(nick, function(user){
			if (user === undefined){
				output(nick, "You are not connected");
			}else{
				Pickaxe.getByUserId(user.id, function(pickaxe){
					const delta = Math.floor(Date.now()/1000) - user.lastMining;
					const rand = Math.random();
					const gold = rand * (delta/86400) * user.level;	//Max 1 per day at lvl 1

					//Hand mining
					User.addGold(nick, gold);
					User.updateLastMining(nick);
					output(nick, "You mined for "+(delta/60).toFixed(2)+" minute(s) at "+(rand*100).toFixed(2)+"% rate, earning "+gold.toFixed(8)+" gold !");

					// Pickaxe mining
					let pickaxeRand;
					let pickaxeGold;
					let damageRand;
					let damage;
					if (pickaxe){
						pickaxeRand = Math.random();
						pickaxeGold = pickaxeRand * (delta/86400) * pickaxe.power;
						damageRand = Math.random();
						damage = damageRand * (delta/86400) * pickaxe.power * cfg.damageRatio;

						Pickaxe.damage(user.id, damage);
						pickaxe.durability -= damage;
						// Destroyed pickaxe
						if (pickaxe.durability-damage <= 0){
							Pickaxe.delete(user.id);
							output(nick, "Your pickaxe broke before you finished and gold has been lost ! Be more careful next time");
						}
						//Pickaxe mining
						else{
							User.addGold(nick, pickaxeGold);
							Pickaxe.addToTotalGoldMined(user.id, pickaxeGold);
							output(nick, "["+pickaxe.name+"] was used to dig, earning "+pickaxeGold.toFixed(8)+" more gold at "+(pickaxeRand*100).toFixed(2)+"% rate and "+pickaxe.power.toFixed(8)+" power")
							output(nick, "Your pickaxe lost "+damage.toFixed(8)+" durability at "+(damageRand*100).toFixed(2)+"% damage rate. Durability left : "+((pickaxe.durability-damage)/pickaxe.maxDurability*100).toFixed(2)+"% ("+
								(Pickaxe.getMinimumRemainingMiningTime(pickaxe)*24).toFixed(2)+"h remaining minimum, average "+
								(Pickaxe.getMinimumRemainingMiningTime(pickaxe)*24*2).toFixed(2)+"h)");
						}
					}
					output(nick, "You now have "+(user.gold+gold+(pickaxe?pickaxe.durability-damage>0?pickaxeGold:0:0)).toFixed(8)+" gold (+"+(gold+(!pickaxe?0:pickaxe.durability-damage<=0?0:pickaxeGold)).toFixed(8)+")");
				});
			}
		});
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

//Create pickaxe
let createPickaxe = function(nick, msg){
	let reg = new RegExp("^create","i")
	let res = msg.match(reg);
	if (res){
		reg = new RegExp("^create (([0-9]*[.])?[0-9]+) ([^]*)","i");
		res = msg.match(reg);
		if (res){
			if (res.length === 4){
				let investment = res[1];
				let name = res[3];
				User.getByNick(nick, function(user){
					if (user !== undefined){
						if (user.gold >= investment){
							User.addGold(nick, -investment);
							const randPower = Math.random();
							const power = randPower*investment*cfg.creationPowerRatio;
							const randDurability = Math.random();
							const durability = randDurability*investment*cfg.creationMaxDurabilityRatio;
							Pickaxe.create(user.id, name, power, durability, investment);
							output(nick, "You created ["+name+"] ! Power : "+power.toFixed(8)+
								" ("+(randPower*100*cgf.creationPowerRatio).toFixed(2)+"% of your investment) | Max durability : "+
								durability.toFixed(8)+" ("+(randDurability*100*cfg.creationMaxDurabilityRatio).toFixed(2)+"% of your investment)");
							output(nick, (Pickaxe.getMinimumRemainingMiningTime(pickaxe)*24).toFixed(2)+"h of mining remaining minimum, average "+
								(Pickaxe.getMinimumRemainingMiningTime(pickaxe)*24*2).toFixed(2)+"h");
						}else{
							output(nick, "You don't have enough gold");
						}
					}else{
						output(nick, "You are not connected.");
					}
				});
			}else{
				output(nick, "Nope. You don't use it correctly. Maybe try the \"create help\" command ?");
			}
		}
		
		reg = new RegExp("^create help","i")
		res = msg.match(reg);
		if (res){
			output(nick, "https://github.com/nolialsea/botcoin");
		}
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

//Upgrade pickaxe
let upgradePickaxe = function(nick, msg){
	let reg = new RegExp("^upgrade","i")
	let res = msg.match(reg);
	if (res){
		reg = new RegExp("^upgrade (([0-9]*[.])?[0-9]+)","i");
		res = msg.match(reg);
		if (res){
			if (res.length === 3){
				let investment = res[1];
				User.getByNick(nick, function(user){
					if (user !== undefined){
						Pickaxe.getByUserId(user.id, function(pickaxe){
							if (pickaxe){
								if (user.gold >= investment){
									User.addGold(nick, -investment);
									const randPower = Math.random();
									const power = randPower*investment*cfg.upgradePowerRatio;
									const randDurability = Math.random();
									const durability = randDurability*investment*cfg.upgradeMaxDurabilityRatio;
									Pickaxe.upgrade(user.id, power, durability, investment);
									output(nick, 
										"You upgrade ["+pickaxe.name+"] ! New power : "+(pickaxe.power+power).toFixed(8)+
										" (+"+power.toFixed(8)+", or "+(randPower*100*cfg.upgradePowerRatio).toFixed(2)+
										"% of your investment) | New max durability : "+(pickaxe.maxDurability+durability).toFixed(8)+
										" (+"+(randDurability*100*cfg.upgradeMaxDurabilityRatio).toFixed(2)+"% of your investment)"
									);
								}else{
									output(nick, "You don't have enough gold");
								}
							}else{
								output(nick, "You don't have a pickaxe");
							}
						});
					}else{
						output(nick, "You are not connected.");
					}
				});
			}else{
				output(nick, "Nope. You don't use it correctly. Maybe try the \"upgrade help\" command ?");
			}
		}
		
		reg = new RegExp("^upgrade help","i")
		res = msg.match(reg);
		if (res){
			output(nick, "https://github.com/nolialsea/botcoin");
		}
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

//Repair pickaxe
let repairPickaxe = function(nick, msg){
	let reg = new RegExp("^repair","i")
	let res = msg.match(reg);
	if (res){
		reg = new RegExp("^repair (([0-9]*[.])?[0-9]+)","i");
		res = msg.match(reg);
		if (res){
			if (res.length === 3){
				let investment = res[1];
				User.getByNick(nick, function(user){
					if (user !== undefined){
						Pickaxe.getByUserId(user.id, function(pickaxe){
							if (pickaxe){
								if (user.gold >= investment){
									User.addGold(nick, -investment);
									const randDurability = Math.random();
									const durability = randDurability*investment*cfg.repairDurabilityRatio;
									Pickaxe.repair(user.id, durability, investment);
									output(nick, "You repaired ["+pickaxe.name+"] ! Durability : "+
										Math.min(pickaxe.durability+durability, pickaxe.maxDurability).toFixed(8)+"/"+pickaxe.maxDurability.toFixed(8)+
										" ("+(Math.min(pickaxe.durability+durability, pickaxe.maxDurability)/pickaxe.maxDurability*100).toFixed(2)+"%, +"+
										(randDurability*100*cfg.repairDurabilityRatio).toFixed(2)+"% of your investment, "+
										(Pickaxe.getMinimumRemainingMiningTime(pickaxe)*24).toFixed(2)+"h remaining (minimum)"+")");
								}else{
									output(nick, "You don't have enough gold");
								}
							}else{
								output(nick, "You don't have a pickaxe");
							}
						});
					}else{
						output(nick, "You are not connected.");
					}
				});
			}else{
				output(nick, "Nope. You don't use it correctly. Maybe try the \"repair help\" command ?");
			}
		}
		
		reg = new RegExp("^repair help","i")
		res = msg.match(reg);
		if (res){
			output(nick, "https://github.com/nolialsea/botcoin");
		}
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

//Display gold
let showGold = function(nick, msg){
	let reg = new RegExp("^gold","i")
	let res = msg.match(reg);
	if (res){
		User.getByNick(nick, function(user){
			if (!user){
				output(nick, "You are not connected");
			}else{
				output(nick, "You have "+user.gold.toFixed(8)+" gold");
			}
		});
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

//Show pickaxe
let showPickaxe = function(nick, msg){
	let reg = new RegExp("^pick(axe)?","i")
	let res = msg.match(reg);
	if (res){
		User.getByNick(nick, function(user){
			if (!user){
				output(nick, "You are not connected");
			}else{
				Pickaxe.getByUserId(user.id, function(pickaxe){
					if (!pickaxe){
						output(nick, "You don't have a pickaxe");
					}else{
						output(nick, "["+pickaxe.name+"]\tPower: "+pickaxe.power.toFixed(8))
						output(nick, "Durability: "+pickaxe.durability.toFixed(8)+"/"+pickaxe.maxDurability.toFixed(8)+
							" ("+(pickaxe.durability/pickaxe.maxDurability*100).toFixed(2)+"%, "+
							(Pickaxe.getMinimumRemainingMiningTime(pickaxe)*24).toFixed(2)+"h remaining (minimum)"+")");
						output(nick, "Upgrades: "+pickaxe.upgrade+"\tRepairs: "+pickaxe.repair);
						output(nick, "Total gold mined: "+pickaxe.totalGoldMined.toFixed(8));
						output(nick, "Total investment: "+pickaxe.totalInvestment.toFixed(8));
					}
				});
			}
		});
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

//Show delta
let showDelta = function(nick, msg){
	let reg = new RegExp("^delta","i")
	let res = msg.match(reg);
	if (res){
		User.getByNick(nick, function(user){
			if (!user){
				output(nick, "You are not connected");
			}else{
				const delta = Math.floor(Date.now()/1000) - user.lastMining;
				output(nick, "Last mining was "+(delta/60).toFixed(2)+" minutes ago");
			}
		});
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

//Show help
let showHelp = function(nick, msg){
	let reg = new RegExp("^help","i")
	let res = msg.match(reg);
	if (res){
		output(nick, "https://github.com/nolialsea/botcoin");
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}
//Show level
let showLevel = function(nick, msg){
	let reg = new RegExp("^l(e)?v(e)?l","i")
	let res = msg.match(reg);
	if (res){
		User.getByNick(nick, function(user){
			if (!user){
				output(nick, "You are not connected");
			}else{
				output(nick, "You are level "+user.level.toFixed(8));
			}
		});
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

//Training
let train = function(nick, msg){
	let reg = new RegExp("^train","i")
	let res = msg.match(reg);
	if (res){
		User.getByNick(nick, function(user){
			if (user === undefined){
				output(nick, "You are not connected");
			}else{
				reg = new RegExp("^train","i");
				res = msg.match(reg);
				if (res){
					const delta = Math.floor(Date.now()/1000) - user.lastMining;
					const rand = Math.random();
					const experience = rand*(delta/86400);

					User.addLevel(nick, experience);
					User.updateLastMining(nick);
					output(nick, "You trained for "+(delta/60).toFixed(2)+" minute(s) at "+(rand*100).toFixed(2)+"% rate, earning "+experience.toFixed(8)+" level(s) !");
					output(nick, "You are now level "+(user.level+experience).toFixed(8));
				}else{
					output(nick, "You use it wrong. Look at https://github.com/nolialsea/botcoin for more information");
				}
			}
		});
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

//Randomize investment
let randomize = function(nick, msg){
	let reg = new RegExp("^randomize","i")
	let res = msg.match(reg);
	if (res){
		User.getByNick(nick, function(user){
			if (user === undefined){
				output(nick, "You are not connected");
			}else{
				reg = new RegExp("^randomize (([0-9]*[.])?[0-9]+)","i");
				res = msg.match(reg);
				if (res){
					const investment = parseFloat(res[1]);
					if (user.gold >= investment){
						const rand = Math.random();
						const ratio = (rand*2)-1;
						const gain = -investment + investment*rand*2;
						User.addGold(nick, gain);
						output(nick, "You " + (ratio < 0 ? "lost" : "won " ) + " " +
						 Math.abs(gain).toFixed(8)+ " gold ("+ (ratio < 0 ? "" : "+") + (ratio*100).toFixed(2)+"% of investment) You now have "+(user.gold+gain).toFixed(8)+" gold");
					}else{
						output(nick, "You don't have enough gold.");
					}
				}else{
					output(nick, "You use it wrong. Look at https://github.com/nolialsea/botcoin for more information");
				}
			}
		});
		return true; //Return true if command is found
	}
	return false;	//Return false if command is not found
}

let parse = function(from, message){
	connect(from, message);
	register(from, message);
	mine(from, message);
	createPickaxe(from, message);
	upgradePickaxe(from, message);
	repairPickaxe(from, message);
	showGold(from, message);
	showPickaxe(from, message);
	showLevel(from, message);
	showDelta(from, message);
	showHelp(from, message);
	train(from, message);
	randomize(from, message);
}

module.exports.parse = parse;